# SOME DESCRIPTIVE TITLE.
# Copyright (C) The text and illustrations in this website are licensed by the Plone Foundation under a Creative Commons Attribution 4.0 International license.
# This file is distributed under the same license as the Mastering Plone package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Mastering Plone 1.2.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-08-05 05:00-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../relations.rst:2
msgid "Relations"
msgstr ""

#: ../relations.rst:4
msgid "Relations are a difficult topic. To master relations you must understand the stack of packages involved."
msgstr ""

#: ../relations.rst:7
msgid "Relations are based on `zc.relation`. This package allows to store transitive and intransitive n-ary relationships. It allows for complex relationships and searches along them. Because of this functionality, the package is a bit complicated."
msgstr ""

#: ../relations.rst:12
msgid "The package `zc.relation` provides its own catalog, a relation catalog. This is a storage optimized for the queries needed. `zc.relation` is sort of an outlier with regards to zope documentation. It has extensive documentation, with a good level of doctests for explaining things."
msgstr ""

#: ../relations.rst:17
msgid "You can use `zc.relation` to store the objects and its relations directly into the catalog. But the additional packages that make up the relation functionality don't use the catalog this way."
msgstr ""

#: ../relations.rst:20
msgid "We want to work with schemas to get auto generated forms. The logic for this is provided by the package `z3c.relationfield`. This package contains the RelationValue object and everything needed to define a relation schema, and all the code that is necessary to automatically update the catalog."
msgstr ""

#: ../relations.rst:25
msgid "A RelationValue Object does not reference all objects directly. For the target, it uses an id it gets from the `IntId` Utility. This id allows direct recovery of the obect. The source object stores it directly."
msgstr ""

#: ../relations.rst:29
msgid "Widgets are provided by `plone.app.z3cform`. Some converters are provided by `plone.app.relationfield`. The widget that Plone uses can also store objects directly. Because of this, the following happens when saving a relation via a form:"
msgstr ""

#: ../relations.rst:33
msgid "The html shows some nice representation of selectable objects."
msgstr ""

#: ../relations.rst:34
msgid "When the user submits the form, selected items are submitted by their UUIDs."
msgstr ""

#: ../relations.rst:35
msgid "The Widget retrieves the original object with the UUID."
msgstr ""

#: ../relations.rst:36
msgid "Some Datamanager gets another unique ID from an IntID Tool."
msgstr ""

#: ../relations.rst:37
msgid "The same datamanager creates a RelationValue from this id, and stores this relation value on the source object."
msgstr ""

#: ../relations.rst:38
msgid "Some Event handlers update the catalogs."
msgstr ""

#: ../relations.rst:40
msgid "It is surprisingly easy to to use RelationFields."
msgstr ""

#: ../relations.rst:42
msgid "I show you how to do it TTW..."
msgstr ""

#: ../relations.rst:44
msgid "If you want to modify Relations, you have to create or delete RelationValue objects. If you want to find out what objects are related to each other, you use the relation catalog. Here is an example:"
msgstr ""

#: ../relations.rst:50
msgid "RelationValue objects have a fairly complete API. For both target and source, you can receive the IntId, the object and the path. On a RelationValue, the terms `source` and `target` aren't used. Instead, they are `from` and `to`. So the API for getting the target is:"
msgstr ""

#: ../relations.rst:56
msgid "`to_id`"
msgstr ""

#: ../relations.rst:57
msgid "`to_path`"
msgstr ""

#: ../relations.rst:58
msgid "`to_object`"
msgstr ""

#: ../relations.rst:60
msgid "In addition, the relation value knows under which attribute it has been stored. You could delete a Relation like this `delattr(rel.from_object, rel.from_attribute)`"
msgstr ""

#: ../relations.rst:64
msgid "This is a terrible idea by the way, because when you define in your schema that one can store multiple RelationValues, your Relation is stored in a list on this attribute."
msgstr ""

#: ../relations.rst:68
msgid "Relations depend on a lot of infrastructure to work. This infrastructure in turn depends a lot on event handlers being thrown properly. When this is not the case things can break. Because of this, there is a method `isBroken` which you can use to check if the target is available."
msgstr ""

#: ../relations.rst:74
msgid "There are alternatives to using Relations. You could instead just store the UUID of an object. But Using real relations and the catalog allows for very powerful things. The simplest concrete advantage is the possibility to see what links to your object."
msgstr ""

